# Story 1.4: Secure Gemini API - Move to Backend

**Epic:** Phase 3 - AI Chat & Maps (Fast-tracked to Phase 1 for security)
**Status:** Draft
**Priority:** CRITICAL SECURITY

## Story

**As a** security-conscious developer,
**I want** Gemini API calls moved from frontend to backend,
**so that** the API key is not exposed in the browser and usage can be controlled.

## Acceptance Criteria

1. ✅ Gemini API key removed from frontend `.env.local`
2. ✅ ChatWidget calls backend function instead of Gemini directly
3. ✅ Backend function `chatWithAI` implemented and deployed
4. ✅ Rate limiting applied to prevent abuse
5. ✅ Chat context includes dynamic data from Firestore (units, bookings availability)
6. ✅ Frontend chat experience unchanged (same UX)

## Tasks / Subtasks

- [ ] Review Current Implementation (Security Audit)
  - [ ] Identify where Gemini API is called in frontend
  - [ ] Check if `VITE_GEMINI_API_KEY` is exposed in browser DevTools
  - [ ] Document current chat prompts and context

- [ ] Implement Backend Chat Function (AC: 3)
  - [ ] Verify `functions/src/services/gemini.service.ts` exists
  - [ ] Implement `chatWithAI` cloud function in `functions/src/index.ts`
  - [ ] Add Gemini API key as Firebase secret (done in Story 1.3)
  - [ ] Create chat endpoint: POST `/chatWithAI`
  - [ ] Accept parameters: `message`, `conversationHistory?`

- [ ] Add Dynamic Context from Firestore (AC: 5)
  - [ ] Query `units` collection for available units
  - [ ] Include unit details in Gemini system prompt
  - [ ] Add booking availability context (if needed)
  - [ ] Keep context concise to reduce token usage

- [ ] Implement Rate Limiting (AC: 4)
  - [ ] Add rate limit: max 10 requests per IP per minute
  - [ ] Use Firebase Functions rate limiting or express-rate-limit
  - [ ] Return 429 status code when limit exceeded
  - [ ] Add user-friendly error message

- [ ] Update Frontend ChatWidget (AC: 2, 6)
  - [ ] Modify `src/components/ChatWidget.tsx`
  - [ ] Replace direct Gemini SDK call with fetch to backend function
  - [ ] Handle loading states
  - [ ] Handle errors (rate limit, network errors)
  - [ ] Keep same UI/UX (users shouldn't notice change)

- [ ] Remove Frontend API Key (AC: 1)
  - [ ] Delete `VITE_GEMINI_API_KEY` from `.env.local`
  - [ ] Remove `@google/genai` import from ChatWidget
  - [ ] Remove Gemini SDK from frontend package.json (optional, can keep for types)

- [ ] Test & Deploy (AC: 1-6)
  - [ ] Deploy function: `firebase deploy --only functions:chatWithAI`
  - [ ] Test chat widget in browser
  - [ ] Verify API key is NOT in Network tab
  - [ ] Test rate limiting by sending 11 quick messages
  - [ ] Verify chat responses are still relevant

## Dev Notes

### Current State (SECURITY ISSUE)
[Source: Assessment by Sarah]
- ⚠️ **CRITICAL**: Gemini API key is currently in `VITE_GEMINI_API_KEY`
- This exposes the key in browser (visible in DevTools → Network/Sources)
- Anyone can extract and abuse the API key
- ChatWidget directly calls Gemini from frontend

### Backend Function Structure
[Source: architecture/6-api-design.md, functions/src/services/gemini.service.ts]

```typescript
// functions/src/index.ts
import { onRequest } from 'firebase-functions/v2/https';
import { defineSecret } from 'firebase-functions/params';
import { GeminiService } from './services/gemini.service';

const geminiKey = defineSecret('GEMINI_API_KEY');

export const chatWithAI = onRequest(
  {
    secrets: [geminiKey],
    cors: true,
    timeoutSeconds: 30,
    memory: '256MiB'
  },
  async (request, response) => {
    // Rate limiting check
    // ...

    const { message, conversationHistory } = request.body;

    // Get dynamic context from Firestore
    const units = await getUnitsFromFirestore();
    const systemPrompt = buildSystemPrompt(units);

    // Call Gemini
    const geminiService = new GeminiService(geminiKey.value());
    const reply = await geminiService.chat(message, systemPrompt, conversationHistory);

    response.json({ reply });
  }
);
```

### Rate Limiting Pattern
[Source: architecture/12-security-integration.md]
```typescript
import { RateLimiterMemory } from 'rate-limiter-flexible';

const rateLimiter = new RateLimiterMemory({
  points: 10, // Number of requests
  duration: 60, // Per 60 seconds
});

// In function handler:
try {
  await rateLimiter.consume(request.ip);
} catch {
  response.status(429).json({ error: 'Too many requests' });
  return;
}
```

### Frontend API Call Pattern
```typescript
// src/components/ChatWidget.tsx
const sendMessage = async (message: string) => {
  try {
    const response = await fetch('https://YOUR-REGION-PROJECT.cloudfunctions.net/chatWithAI', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ message, conversationHistory }),
    });

    if (!response.ok) {
      if (response.status === 429) {
        throw new Error('Too many requests. Please wait a moment.');
      }
      throw new Error('Failed to get response');
    }

    const { reply } = await response.json();
    return reply;
  } catch (error) {
    // Handle error
  }
};
```

### System Prompt with Dynamic Context
```typescript
function buildSystemPrompt(units: Unit[]): string {
  return `You are Flora, a helpful assistant for Recanto da Natureza...

Available accommodations:
${units.map(u => `- ${u.name}: ${u.description} (€${u.pricePerNight}/night)`).join('\n')}

Answer questions about the property, accommodations, and help with bookings.`;
}
```

### Testing
[Source: architecture/11-testing-strategy.md]
- Manual test: Send message in chat widget
- Security test: Check Network tab - API key should NOT be visible
- Rate limit test: Send 11 messages quickly - 11th should fail with 429
- Verify DevTools → Sources doesn't contain API key

### Cost Considerations
- Gemini API: ~$0.001 per request (Gemini 1.5 Flash)
- Rate limiting reduces abuse risk
- Monitor usage in Google AI Studio dashboard

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-10 | 1.0 | Initial story creation | Bob (SM) |

## Dev Agent Record

### Agent Model Used
_To be filled by Dev agent_

### Debug Log References
_To be filled by Dev agent_

### Completion Notes
_To be filled by Dev agent_

### File List
_To be filled by Dev agent_

## QA Results
_To be filled by QA agent_
